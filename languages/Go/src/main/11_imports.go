package main

/*
https://rakyll.org/style-packages/

Все файлы *.go в одной директории должны иметь одно название пакета
Исключение - *_test.go, т.к. они игнорируются при сборке программы
Пакет - совокупность go-файлов в одной директории.
Для создания исполняемого файла используется пакет main.

Экспорт.
Для экспорта переменных / функций / etc используется именование с заглавной буквы.
Именованные со строчной буквы сущности экспортированы не будут.

Порядок импорта:
- Начало компиляции программы с пакета main
- Импортов всех пакетов, указанных в main
- Инициализация init() пакетов в том же порядке
- Запуск main()

Конвенция по организации проекта - Standard Go Project Layout.
https://github.com/golang-standards/project-layout

root
 |-- cmd/                     Бинарные исполняемые файлы
 |    |-- client/
 |          |-- main.go
 |    |-- server/
 |          |-- main.go
 |-- internal/                Неимпортируемый исходный код
 |
 |-- pkg/                     Импортируемый исходный код
 |
 |-- vendor/                  Внешние пакеты
 |
 |-- test/
 |
 |-- docs/
*/

// Импорты идут сразу после объявления пакета
// Путь импорта указывается относительно $GOPATH/src
import "fmt"
import (
	"encoding/json"

	// Пустой импорт неиспользуемого пакета для его инициализации.
	// Используется для отладки или импорта аннотаций в комментариях.
	_ "embed"
	// Импорт внешней зависимости
	// "github.com/yuin/goldmark"
	// Или с синонимом
	// yaml "gopkg.in/yaml.v2"
)

// Аннотация, переменная проинициализирована содержимым файла
//go:embed 00_hello_world.go
var helloWorld string

func main() {
	fmt.Println("Std lib:", json.Encoder{})
	fmt.Println("helloWorld:", helloWorld)
}

/*
Модуль - совокупность пакетов, может быть установлен как внешняя библиотека.
------------------------------
Метаданные о модуле указываются в go.mod, размещающемся в корне проекта.
Создание модуля: `go mod init modulename`
Все изменения в go.mod вносятся соответствующей командой.

Образец содержимого `go.mod`:

Первая строка go.mod содержит путь импорта - префикс, относительно
которого будут импортироваться все пакеты этого модуля.
module modulename

Версия, использованная при создании этого модуля
go 1.18

Путь в файловой системе к другому модулю
replace anothermodule => ../anothermodule

Т.к. другой модуль будет содержать пакеты и зависимости,
их необходимо установить: `go get anothermodule`
В go.mod появится строка (эта версия будет использоваться при сборке):
require anothermodule v0.0.0-00010101000000-000000000000 // indirect
*/
